[{"categories":["Paper"],"content":"动词短语 come to the fore 脱颖而出 play a dominating role 很重要 ","date":"2021-11-05","objectID":"/writing/:1:0","tags":["Writing","Paper"],"title":"For writing paper","uri":"/writing/"},{"categories":["Paper"],"content":"状语短语 motivated by these observations 受这些观察的启发 ","date":"2021-11-05","objectID":"/writing/:2:0","tags":["Writing","Paper"],"title":"For writing paper","uri":"/writing/"},{"categories":["Methods","Code"],"content":"写在前面：最近几天新冠病毒疫情还未平息，在家帮女票研究波浪模型的时候探索了一下用Matlab进行波浪数值模拟的简单方法，在这里写一个简单教程，因为我在网上也没有找到写的比较完整的波浪模拟代码，所以来这里占个坑，希望对大家有所帮助。 ","date":"2020-02-17","objectID":"/matlabwavesimulation/:0:0","tags":["船舶与海洋工程","数值模拟"],"title":"Matlab波浪数值模拟","uri":"/matlabwavesimulation/"},{"categories":["Methods","Code"],"content":"理论依据 详情参考这两篇论文： [1] 刘素美. 波浪数值模拟[J]. 科技与创新, 2018(13):132-133. [2] 赵珂,李茂华,郑建丽,田冠楠. 基于波浪谱的三维随机波浪数值模拟及仿真[J]. 舰船科学技术, 2014,36(02):37-39. 简单来说就是，波浪的模拟，可以由不同方向角、不同频率的很多个波，用随机的初始相位初始化后叠加得到。显然，组成波浪的波的频率个数越多、方向角个数越多，能够形成的波就更复杂（直观上也更真实）。 先给出波面模型的公式（根据文献[1]） $$ z = \\eta(x, y, t)=\\sum_{i=1}^{M} \\sum_{j=1}^{N} \\zeta_{i j} \\cos [{k}_{i}\\left(x \\cos \\alpha_{d j}+y \\sin \\alpha_{d j}\\right)-\\omega_{di}t+\\beta_{ij} $$ 其中$\\zeta_{ij},k_{i},\\alpha_{dj},\\omega_{di},\\beta_{ij}$分别为波浪的波幅、波数、方向角、频率和相位角。且$k_{i} = \\omega_{di}^{2}/g$。 可以看出，其中$x,y,t$是需要输入的参数，即坐标位置和时间，$z$就是波面高度，由于波的形成需要如上的这些参数。其中方向角和频率是需要进行划分的，其余的参数全都可以由不同的方向角和频率计算得到，下面讲波浪参数的确定。 ","date":"2020-02-17","objectID":"/matlabwavesimulation/:1:0","tags":["船舶与海洋工程","数值模拟"],"title":"Matlab波浪数值模拟","uri":"/matlabwavesimulation/"},{"categories":["Methods","Code"],"content":"方向角划分和选取 对传播方向角$\\alpha$进行划分时，设方向角的变化范围为主波向$\\alpha_{main}$两侧$[-\\pi/2,\\pi/2]$的范围，将此区域$N$等分，每一份的宽度为$d\\alpha=\\pi/N$（论文这里写的有误，请大家注意），选取每段的中心值作为方向角$\\alpha_{dj}$。 ","date":"2020-02-17","objectID":"/matlabwavesimulation/:1:1","tags":["船舶与海洋工程","数值模拟"],"title":"Matlab波浪数值模拟","uri":"/matlabwavesimulation/"},{"categories":["Methods","Code"],"content":"频率的划分和选取 论文中给定了频率选取区间的计算方式，这里不做描述，直接关注频率的划分公式 $$\\omega_{i}=\\left[\\frac{3.11}{H_{1 / 3}^{2} \\ln (M+2 / i)}\\right]^{1 / 4}$$ $$\\omega_{di}=\\frac{\\omega_{i+1}+\\omega_{i}}{2}$$ 这里采用等分能量法分割频率，将频率划分为$M$个等能量的区间，$\\omega_{i}$是各区间的分界频率，$\\omega_{di}$是各频率区间的中心值作为选取的频率。 备注：原文中第一个公式中是$M/i$，因为i的取值只能是从1~M-1，所以只能产生M-2个区间，这里坐了一下修改，保证M的个数与选取的频率个数相同 ","date":"2020-02-17","objectID":"/matlabwavesimulation/:1:2","tags":["船舶与海洋工程","数值模拟"],"title":"Matlab波浪数值模拟","uri":"/matlabwavesimulation/"},{"categories":["Methods","Code"],"content":"利用三维随机波浪谱确定波幅$\\zeta_{ij}$ 标准波浪谱为PM谱 $$S_{PM}(\\omega)=\\frac{0.78}{\\omega^{5}}exp[-\\frac{3.11}{\\omega^{4}H_{1/3}^{2}}]$$ 其中$H_{1/3}=0.0214v^{2}$为有义波高，$v$是海面风速，会影响波浪高度。由于PM 谱描述的是能量随频率的变化，而对于三维随机波浪，其能量分布与频率和方向角都有关，并且认为频率和方向角的影响相互独立，则引入只与方向角$\\alpha$有关的方向扩展谱函数$D_{f}(\\alpha)$ $$D_{f}(\\alpha)=\\frac{2}{\\pi} \\cos ^{2} \\alpha,\\left(-\\frac{\\pi}{2} \\leqslant \\alpha \\leqslant \\frac{\\pi}{2}\\right)$$ 最终得到三位随机波浪的方向波谱： $$S_{3D}(\\omega,\\alpha)=S_{PM}(\\omega)D_{f}(alpha)$$ 将划分好的频率和方向角代入下式，即可得到每个单元组成波的波幅$\\zeta_{ij}$ $$\\zeta_{ij}=\\sqrt{2S(\\omega,\\alpha)d{\\omega}d{\\alpha}}$$ 备注：论文这里公式有误，我已经做了修改 ","date":"2020-02-17","objectID":"/matlabwavesimulation/:1:3","tags":["船舶与海洋工程","数值模拟"],"title":"Matlab波浪数值模拟","uri":"/matlabwavesimulation/"},{"categories":["Methods","Code"],"content":"随机初始相位$\\beta_{ij}$的生成 文中写的是线性乘同余法，其实用简单的$0-2\\pi$的均匀分布随机采样就可以。 ","date":"2020-02-17","objectID":"/matlabwavesimulation/:1:4","tags":["船舶与海洋工程","数值模拟"],"title":"Matlab波浪数值模拟","uri":"/matlabwavesimulation/"},{"categories":["Methods","Code"],"content":"基本实现的静态波浪生成代码 n = 64; map = zeros(n,n); M = 1; % ferequence number N = 50; beta = 2*pi*rand(M,N); for x = 1:n for y=1:n map(x,y) = bo(x,y,M,N,beta); end end XX = 1:n; YY = 1:n; surf(XX, YY, map); axis([-5, n+5, -5, n+5, -5, 5]) functionH =bo(x,y,M,N,beta)t = 0; v = 5; g = 9.8; H_value = 0.0214*v^2; alpha_main = 0; da = pi/N; a = alpha_main-pi/2+da/2 : da : alpha_main+pi/2-da/2; wi = (3.11./(H_value^2*log((M+2)./(1:M+1)))).^(1/4); % wi = zeros(M+1,1); % for i = 1:M+1 % wi(i) = (3.11/(H_value^2*log((M+2)/i)))^(1/4); % end w = (wi(2:end)+wi(1:end-1))/2; dw = wi(2:end)-wi(1:end-1); % w = zeros(M,1); % dw = zeros(M,1); % for i = 1:M % w(i) = (wi(i+1)+wi(i))/2; % dw(i) = wi(i+1)-wi(i); % end H = 0; for i=1:M for j=1:N adj = a(j); wdi = w(i); Spm_w = 0.78*exp(-3.11/(wdi^4*H_value^2))/wdi^5; Df_alpha = 2*(cos(adj)^2)/pi; S3d = Spm_w*Df_alpha; A = sqrt(2*S3d*dw(i)*da); ki = wdi^2/g; H = H + A*cos(ki*(x*cos(adj)+y*sin(adj))-wdi*t+beta(i,j)); end end end 静态波浪静态波浪 \"\r静态波浪\r ","date":"2020-02-17","objectID":"/matlabwavesimulation/:2:0","tags":["船舶与海洋工程","数值模拟"],"title":"Matlab波浪数值模拟","uri":"/matlabwavesimulation/"},{"categories":["Methods","Code"],"content":"波浪的动态实现 （计算已改为矩阵并行化，为了提升实时的渲染速度） n = 100; t = 1; v = 8; M = 15; N = 15; g = 9.8; H_value = 0.0214*v^2; alpha_main = 0; beta = 2*pi*rand(M,N); da = pi/N; a = alpha_main-pi/2+da/2 : da : alpha_main+pi/2-da/2; wi = (3.11./(H_value^2*log((M+2)./(1:M+1)))).^(1/4); % wi = zeros(M+1,1); % for i = 1:M+1 % wi(i) = (3.11/(H_value^2*log((M+2)/i)))^(1/4); % end w = (wi(2:end)+wi(1:end-1))/2; dw = wi(2:end)-wi(1:end-1); % w = zeros(M,1); % dw = zeros(M,1); % for i = 1:M % w(i) = (wi(i+1)+wi(i))/2; % dw(i) = wi(i+1)-wi(i); % end Spm_w = 0.78*exp(-3.11./(w.^4*H_value^2))./w.^5; Df_alpha = 2*(cos(a).^2)/pi; S3d = Spm_w'*Df_alpha; A = sqrt(2*S3d.*(dw'*da)); ki = w.^2/g; A = repmat(A(:)', n*n, 1); aj = repmat(a, M, 1); a = aj(:)'； ki = ki'; ki = repmat(ki, 1, N); k = ki(:)'; extend_w = repmat(w',1,N); extend_w = repmat(extend_w(:)', n*n, 1); beta = repmat(beta(:)', n*n, 1); XX = 1:n; YY = 1:n; [X,Y] = meshgrid(XX, YY); t0 = 0; dt = 0.1； T = 100; X = reshape(X, n*n, 1); Y = reshape(Y, n*n, 1); clf shg set(gcf); MAP = wave2(X,Y,A,k,a,extend_w,t0,beta); MAP = reshape(MAP, n, n); surfplot = surf(XX, YY, MAP); %shading interp axis([-5,n+5,-5,n+5,-10,10]) for t = 0:dt:T MAP = wave2(X,Y,A,k,a,extend_w,t,beta); MAP = reshape(MAP, n, n); set(surfplot,'zdata',MAP); % shading interp drawnow end functionwave =wave2(X,Y,A,k,a,extend_w,t,beta)wave = sum(cos((X*cos(a)+Y*sin(a)).*k-extend_w.*t+beta).*A,2); end 动态波浪动态波浪 \"\r动态波浪\r ","date":"2020-02-17","objectID":"/matlabwavesimulation/:3:0","tags":["船舶与海洋工程","数值模拟"],"title":"Matlab波浪数值模拟","uri":"/matlabwavesimulation/"},{"categories":["Methods"],"content":"1. Adversarial nets 为了从data $X$ 中学习generator的分布 $p_g$ ，首先定义一个先验的噪声变量分布 $p_{\\boldsymbol{z}}(\\boldsymbol{z})$，然后用 $G\\left(\\boldsymbol{z} ; \\theta_{g}\\right)$ 表示从 $z$ 到 $x$ 空间的映射，$G$ 是由多层感知机表示的可微函数。然后我们再定义一个多层感知机 $D\\left(\\boldsymbol{x} ; \\theta_{d}\\right)$ 输出一个数值，这个数值表示 $x$ 来自data的概率（而不是 $p_g$ ）。我们训练 $D$ 去最大化给训练样本和从 $G$ 中采样生成的样本分配正确标签的概率。同时训练 $G$ 去最小化 $\\log (1-D(G(z)))$。 换言之，$D$ 和 $G$ 在玩一个minimax game： $$\\min_{G} \\max_{D} V(D, G)=\\mathbb{E}_{\\boldsymbol{x} \\sim p_{\\text { data }}(\\boldsymbol{x})}[\\log D(\\boldsymbol{x})]+\\mathbb{E}_{\\boldsymbol{z} \\sim p_{\\boldsymbol{z}}(\\boldsymbol{z})}[\\log (1-D(G(\\boldsymbol{z})))]$$ See Figure 1 for a less formal, more pedagogical explanation of the approach. ExplanationExplanation \"\rExplanation\r ","date":"2019-07-23","objectID":"/gan/:1:0","tags":["GAN","Generative model"],"title":"GAN","uri":"/gan/"},{"categories":["Methods"],"content":"2. Theoretical Results Training approachTraining approach \"\rTraining approach\r ","date":"2019-07-23","objectID":"/gan/:2:0","tags":["GAN","Generative model"],"title":"GAN","uri":"/gan/"},{"categories":["Methods"],"content":"2.1 Global Optimality of $p_{g}=p_{\\text { data }}$ 我们首先考虑，对于任意的generator $G$ 去优化discriminator $D$ Proposition 1. 对于给定的 $G$，最优的 $D$ 是 $$D_{G}^{*}(\\boldsymbol{x})=\\frac{p_{\\text {data}}(\\boldsymbol{x})}{p_{\\text {data}}(\\boldsymbol{x})+p_{g}(\\boldsymbol{x})}$$ 注意，针对D的训练目标可以解释为最大化条件概率 $P(Y=y | \\boldsymbol{x})$ 的最大似然函数。 则minimax game可以重新表示为： $$\\begin{aligned} C(G) \u0026 = \\max_{D} V(G, D) \\\\ \u0026 =\\mathbb{E}_{\\boldsymbol{x} \\sim p_{\\text { data }}}\\left[\\log D_{G}^{*}(\\boldsymbol{x})\\right]+\\mathbb{E}_{\\boldsymbol{z} \\sim p_{\\boldsymbol{z}}}\\left[\\log \\left(1-D_{G}^{*}(G(\\boldsymbol{z}))\\right)\\right] \\\\ \u0026 = \\mathbb{E}_{\\boldsymbol{x} \\sim p_{\\text { data }}}\\left[\\log D_{G}^{*}(\\boldsymbol{x})\\right]+\\mathbb{E}_{\\boldsymbol{x} \\sim p_{g}}\\left[\\log \\left(1-D_{G}^{*}(\\boldsymbol{x})\\right)\\right] \\\\ \u0026 = \\mathbb{E}_{\\boldsymbol{x} \\sim p_{\\text { data }}}\\left[\\log \\frac{p_{\\text { data }}(\\boldsymbol{x})}{P_{\\text { data }}(\\boldsymbol{x})+p_{g}(\\boldsymbol{x})}\\right]+\\mathbb{E}_{\\boldsymbol{x} \\sim p_{g}}\\left[\\log \\frac{p_{g}(\\boldsymbol{x})}{p_{\\text { data }}(\\boldsymbol{x})+p_{g}(\\boldsymbol{x})}\\right] \\end{aligned}$$ Theorem 1. 当且仅当$p_{g}=p_{\\text { data }}$时，C(G)取得全局最小值。最小值为-log4。 $$ C(G)=-\\log (4)+K L\\left(p_{\\text { data }} | \\frac{p_{\\text { data }}+p_{g}}{2}\\right)+K L\\left(p_{g} | \\frac{p_{\\text { data }}+p_{g}}{2}\\right) $$ $$ C(G)=-\\log (4)+2 \\cdot J S D\\left(p_{\\mathrm{data}} | p_{g}\\right) $$ ","date":"2019-07-23","objectID":"/gan/:2:1","tags":["GAN","Generative model"],"title":"GAN","uri":"/gan/"},{"categories":["Methods"],"content":"2.2 Convergence of Algorithm 1 Proposition 2. 如果G和D的能力足够强，在algorithm 1的每一步，D对于每一个给定的G给出最优解，并且$p_g$以提升如下的目标去更新参数： $$\\begin{aligned} C(G) \u0026 = \\max_{D} V(G, D) \\\\ \u0026 \\mathbb{E}_{\\boldsymbol{x} \\sim p_{\\text { data }}}\\left[\\log D_{G}^{*}(\\boldsymbol{x})\\right]+\\mathbb{E}_{\\boldsymbol{x} \\sim p_{g}}\\left[\\log \\left(1-D_{G}^{*}(\\boldsymbol{x})\\right)\\right] \\end{aligned}$$ 那么，$p_g$将收敛于$p_{data}$。 ","date":"2019-07-23","objectID":"/gan/:2:2","tags":["GAN","Generative model"],"title":"GAN","uri":"/gan/"},{"categories":["Methods"],"content":"3. Conclusion Challenges in generative modelingChallenges in generative modeling \"\rChallenges in generative modeling\r Advantages and disadvantages Disdvantages $p_g(x)$没有准确的表示 在训练期间，$D$必须与$G$同步（尤其是，在不更新$D$的情况下$G$不能训练太多次） Advantages 不需要Markov chain了，只有通过backprop获得梯度 学习过程不需要推理 可以将更广泛的函数合并到模型中 Adversarial模型也从生成网络中获得了一些统计优势（不是用数据样本直接更新参数，而是使用流经discriminator的梯度），这意味着输入的组成不是直接复制generator的参数；另一个优势是，它可以表征非常尖锐，甚至退化的分布，而基于马尔可夫链的方法要求分布比较模糊，以便链条能够在模式之间混合 ","date":"2019-07-23","objectID":"/gan/:3:0","tags":["GAN","Generative model"],"title":"GAN","uri":"/gan/"},{"categories":["Methods"],"content":"Referance Goodfellow I, Pouget-Abadie J, Mirza M, et al. Generative adversarial networks[J]. Communications of the ACM, 2020, 63(11): 139-144. Goodfellow I. Nips 2016 tutorial: Generative adversarial networks[J]. arXiv preprint arXiv:1701.00160, 2016. ","date":"2019-07-23","objectID":"/gan/:4:0","tags":["GAN","Generative model"],"title":"GAN","uri":"/gan/"}]